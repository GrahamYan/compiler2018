// Target: Simulate a Bulgarian-solitaire game.
// Possible opitimization: Dead code elimination, common expression, inline function, loop unrolling, etc.
// REMARKS: A funny game. If you like, you can try to prove that when n=1+2+..+i(i>0), the game will always stop
//          and converge to the only solution: {1,2,...i}.   :)

int n;
int h;
int now;
int[] a;
int A = 48271;
int M = 2147483647;
int Q;
int R;
int seed=1;

bool pd(int x) {
    for (;h <= x; ++h)
        if (x == h * (h + 1) / 2){
			bool fuck = true;
			return fuck;
		}	
    return false;
}

int main() {
    int i = 0;
	int temp = 0;
	int count = 0;
	bool fff = true;
	n = 3 * 7 * 10;
	h = 0;
	println(toString(n));
	a = new int[100];
    Q = M / A;
	println(toString(Q));
    R = M % A;
	println(toString(R));
    if (!pd(n)) {
        println("Sorry, the number n must be a number s.t. there exists i satisfying n=1+2+...+i");
        return 1;
    }
    println("Let's start!");
    return 0;
}
